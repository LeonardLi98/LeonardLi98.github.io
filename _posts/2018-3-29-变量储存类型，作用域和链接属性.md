---
layout:     post
title:      变量储存类型，作用域和链接属性
subtitle:   为函数调用中的堆栈变化做铺垫
date:       2018-03-29
author:     LENKE
header-img: img/post-bg-mma-2.jpg
catalog:    true
tags:       储存类型 作用域 链接属性 堆栈
---

为了了解堆栈变化，去看了一下变量储存类型，作用域和链接属性，这里做个介绍。

##### 储存类型，决定变量储存在哪里，具有什么样的特性

| 变量储存类型       | 储存     | 声明位置                                     | 创建时间                 | 销毁时间           |
| ------------------ | -------- | -------------------------------------------- | ------------------------ | ------------------ |
| 静态变量static     | 静态内存 | 代码块之外的变量或者用static                 | 程序开始                 | 程序结束           |
| 自动变量automatic  | 堆栈     | 代码块内                                     | 执行到代码块的时候才创建 | 程序执行离开代码块 |
| 寄存器变量register | 寄存器内 | 仅仅是特殊的储存位置的自动变量，访问速度更快 | 执行到代码块的时候才创建 | 程序执行离开代码块 |

注意事项：

- 储存类型并不改变作用域。
- 自动储存类型是缺省的储存类型，并且代码块被反复调用的话，自动变量每次都将重新创建，并且在堆栈中的位置可能改变，一般不是上一次的值。自动变量的初值不是在编译时赋予的，而是在函数调用时赋予的，每调用一次函数都会对变量重新赋一次初值，因此除非显式地进行赋值，否则自动变量创建时，他们的值总是垃圾。
- 静态变量是在编译时赋初始值，并且**只赋一次初值**（重复调用不会对静态变量进行多次初始化），默认为0或者空串，因为在内存中的位置已经被固定下来了，无论在什么时候，都是访问的这个位置上的值，或者说，在以后每次调用函数时，只是使用上一次函数被调用结束时变量的值，即便程序可能会离开这个作用域，静态变量都是保留了值的。
- 任何地方用static声明的变量都是静态变量。
- 函数的形式参数不能声明为静态，因为实参总是在堆栈中传递给函数用于支持递归。
- 当static用于函数定义或者代码块之外的变量声明时，用于修改链接属性，从external改为internal，但是储存类型和作用域不受影响，这样声明出的函数或者变量只能在声明的文件中访问。用于声明代码块内部的变量时，用于修改变量储存类型，链接属性和作用域都不受影响。

##### 作用域，决定什么时候变量生效

1. 代码块作用域：在代码块中声明并生效，就是这样直白。代码块作用域的优先级要高于文件作用域，但是范围更小。

   ```
   void fun(int b);
   int a = 3;
   void fun(int b){
   	int a = 2;		//这里的a会覆盖之前声明的a
   	...
   }
   void funtwo(int c){
       ...
   }
   ```

2. 文件作用域：在代码块之外声明，直到文件末都生效。被include包含进来的变量依然具有文件作用域。

3. 原型作用域：在函数原型中声明的参数名，如上面的b，c，实际没啥用。

4. 函数作用域：只用于语句标签，语句标签用于goto，即一个函数中的所有语句标签都要唯一确定——有用，但是最好别用。

##### 链接属性，决定变量（函数）和其他文件的同名变量（函数）的关系

根据链接属性不同，变量分为局部和全局变量。

[链接属性](https://blog.csdn.net/peisir/article/details/54799662)
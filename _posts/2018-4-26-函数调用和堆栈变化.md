---
layout:     post
title:      函数调用和堆栈变化
subtitle:   介绍了在调用函数和返回的时候堆栈的一些变化细节
date:       2018-04-26
author:     LENKE
header-img: img/post-bg-mma-2.jpg
catalog:    true
tags:       堆栈 内存 操作系统 编译原理
---

程序是怎么样运行起来的呢？首先程序装载进入内存成为一个进程，然后进程开始运行。这里讲的就是装载后发生的事情，以及进程中的函数调用的事情。

##### 内存分区，按地址从低到高

* 代码区（.text）：存放函数体的二进制代码，在程序装载准备运行的时候，便完全准备好了。
* 静态区：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域（数据段.data）， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域（BSS段.bss）。程序结束后由系统释放。
* 堆区（.heap）：一般由程序员分配释放， 若程序员不释放，程序结束时可由os回收 。在c语言中，常见的是malloc和free等函数。
* 空闲内存
* 栈区（.stack）：由编译器自动分配释放 ，存放函数的参数，局部变量等，用于保存和恢复现场

##### 活动记录，栈帧

计算机内如何确定函数的变量？

栈帧（stack frame）：机器用栈来**传递过程参数，存储返回信息，保存寄存器用于以后恢复，以及本地存储**。为单个过程(函数调用)分配的那部分栈称为栈帧。也叫活动记录。因为在函数不断的调用中，产生了很多很多的活动记录，使得栈被切割成小块，故称为栈帧。

为了方便介绍，我们称调用函数为caller，被调用函数成为callee。

简单的程序只需要代码和静态的变量储存就可以了，而复杂的程序有动态变量甚至是引用了动态库。为什么要介绍这个栈帧呢？我们知道有些函数是递归的，即一个调用另一个，无限地调用下去，直到开始返回，这样就需要储存n个函数的参数值，局部变量的值，由于是不确定的空间大小，所以为了方便管理，把函数调用的信息（栈帧）都储存在内存的栈里，栈帧堆叠然后慢慢地积累再溶解，就是程序运行的过程。

有两个寄存器记录在栈中的栈帧地址，是扩展基址指针寄存器**ebp**（Extended base pointer）和扩展堆栈指针寄存器**esp**（Extended stack pointer）。ebp指向了栈帧的底部，高地址，esp指向了栈帧的顶部，低地址。我们只用两个寄存器就可以完整记录全部函数的位置，怎么办到的呢？因为函数都是一个接一个执行的，所以只需要一次记录一个函数的栈帧，然后在这个栈帧里记录caller的栈帧就行了。好比火车开在有限的铁轨上，要从成都开往重庆，成都到内江，内江知道上一站是成都，然后把铁轨铺设到重庆，内江到重庆，重庆知道上一站是内江，然后在重庆掉头的时候，重新把铁轨铺回去，铺到内江的时候，知道要到成都去，然后再铺到成都就行了。还有一个**pc**指针，指向当前程序的下一条指令，这个大概是熟悉度最高的寄存器了。

总而言之，pc记录了代码段的状态。ebp，esp记录了堆栈段的状态。代码段一般是只读的，防止被破坏。静态区储存了静态变量。

而栈帧需要储存什么呢？

1. 返回指针：callee的返回地址，即栈帧中需要知道是caller在栈的哪里的，以便于callee结束后返回，把pc指向正确的地方。
2. 动态连接：储存了caller的ebp
3. 静态连接：储存了callee的直接外层函数和与caller的层次差，以便函数能引用非局部变量。
4. 现场保护
5. 局部变量：这里指的不是静态变量
6. 等等

注意，这是简化模型，真实情况也差不多，但是有些区别。

##### 真的开始了

调用某一个函数的时候，把ebp先保存起来，再把ebp指向esp的位置，再把esp往地址更低的地方指，使得ebp和esp能够完全指示这个栈帧。

```c
int fun1();
void fun2();
int main(){
    int d = 0;
    int e = 1；
    fun2(d);
    return 1;
}
int fun1(int a){
    return a + 1;
}
void fun2(int c){
    int b = 2;
    b = fun1()+c;
}
```

把栈理解成一个数组，把ebp，esp理解成指针，堆栈段变化如下：

| 指针位置变化          | 从左往右看，从上往下看 |       |                                      |                           |         |
| --------------------- | ---------------------- | ----- | ------------------------------------ | ------------------------- | ------- |
| 调用main的函数的epb-> |                        |       |                                      |                           |         |
|                       | 忽略                   |       |                                      |                           |         |
| 调用main的函数的esp-> | main函数参数           |       |                                      |                           |         |
|                       |                        | esp-> | main函数的返回地址，即pc指向的代码段 |                           |         |
|                       |                        |       |                                      | main函数开始，main的ebp-> | 旧的ebp |



| main的ebp-> | 旧的ebp   |            |      |                 |                                    |
| ----------- | --------- | ---------- | ---- | --------------- | ---------------------------------- |
|             | 静态链接0 |            |      |                 |                                    |
|             | d = 0     |            |      |                 |                                    |
|             | e = 1     |            |      |                 |                                    |
| esp->       |           | fun2的参数 | 0    |                 |                                    |
|             |           | esp->      |      |                 |                                    |
|             |           |            |      |                 | fun2的返回地址，即main现在pc的位置 |
|             |           |            |      | fun2开始，ebp-> | main的ebp                          |
|             |           |            |      |                 | 静态链接和局部变量                 |
|             |           |            |      | esp->           |                                    |

用表格实在是不知道怎么表达。。。不过我想意思应该表达清楚了的。解释一下有几点值得注意的：

* esp永远指向的是堆栈的下一条内容的地址。
* 静态链接指的是指向直接外层程序的栈帧的指针，数字是静态层次，表示和最外层的栈帧有几层差距，main是0层，fun2是1层，fun1是2层。
* 参数按照从右到左的顺序压入栈中。
* 每个函数的访问范围是传进来的参数到esp。
* 这里采用栈向下生长

汇编伪代码：（因为我很多不会写……）

```assembly
main:
	push 0;
	call fun2; 			此时相当于执行	push pc+n;		jmp fun2；这个n是最后这两个指令的长度,返回						 的时候就可以执行call fun2的下一条指令了
	...
fun2:
	push ebp;			即main的ebp被保存了起来
	mov ebp esp;		fun2的ebp是现在esp指向的地方，执行完成后esp再次自动变化
	push 静态链接;
	add esp 12;			esp直接指向后面预定的位置，新的栈顶
	mov ebp-8,2;		把b=2存在ebp下面8的位置，ebp-4是静态链接
	call fun1;			调用fun1
	...;				处理返回值	
```

完成调用后的堆栈将呈现如此情形：

------- 这部分由 caller 设置

saved_ip # 返回地址

argv[argc]

...

argv[1]

argv[0]

argc
------- 以下属于 callee 添加的

saved_bp  # caller 的栈帧地址 <-- 保存完以后 ebp 指向这里

静态链接的信息

locals[0]

locals[1]



##### 总结堆栈变化过程

每个程序和函数的开始，在堆栈段都有这样的过程：

1. 参数按顺序从右到左压栈，压栈参数个数
2. 返回地址压栈——把pc指针的值保存到堆栈中便于返回。为什么先传参数呢？因为call fun2;的长度是固定的，所以在push pc+n;jmp fun2;的时候，**n是确定的值**，按照系统不同有不同取值，自动确定，如果后压栈参数的话，参数不同会导致pc移动的长度不一定，能自动确定的何必自己去确定呢。
3. 前两项都在调用者caller的活动中完成，此后pc指向fun2，进入callee的代码，下面才是callee执行的
4. 保存动态链接——把（旧）ebp的值存到现在的栈顶（esp指向的地方），通过这个ebp可以在函数返回的时候还原旧的栈帧
5. 创建新的栈帧——把esp中的地址放入ebp，或者说，把ebp指向现在的栈顶，注意此时esp没有变化。按照定义，实际上栈帧包括了从步骤1开始压入栈的全部内容，即ebp并不是指向的栈帧的底部，而是在栈帧底部往低地址再走两个，其实纠结这个也没意思，参数到底是caller还是callee栈帧的内容，无伤大雅。注意这里参数在ebp的上方，局部变量在ebp的下方，于是可以很方便地用**ebp[n]**的方式来引用变量，用**ebp[-n]**来引用参数，如果先压栈返回地址，再压栈局部变量，就没有这样的对称性。我们再看第一条，为什么是从右到左压栈，因为以ebp为中心更加方便确定顺序，在表格下面的示例可以看出，数字序号是对称的，非常优雅。
6. 压栈静态链接——用于确定变量的**作用域**，代码段执行遇到某个变量的时候，先到相应堆栈段中寻找，再到上一层的堆栈段中寻找，静态层次之间的差值要为正才能查找，比如fun2（1），可以去main（0）中查找，而不能去fun2（2）中查找，也不能去main中的另一个函数fun3（1）中查找。程序目前运行的局部变量全部都可以在栈帧中找到，或者是静态连接往上层找到。如此可以很清楚明白地联想到，为什么caller的局部变量会被callee的局部变量覆盖掉，因为是先访问的callee的堆栈，找到了便不会在caller的堆栈中寻找。
7. 压栈各个局部变量
8. 每一次压栈esp自减
9. 以上都是说的半静态变量，注意这个静态变量是指变量的大小，在活动记录中的位置在运行之前就可以确定，和之前说的静态变量在定义上有区别。静态变量储存在静态区，局部静态变量也一样；半静态变量，在编译时大小可以确定，但是偏移量在运行时才能确定；半动态变量，程序运行到某个特殊地方的时候才能确定大小，eg，用户输入一个数字n，创建数组a[n]；动态变量，完全无法确定大小，随时可以变化，

##### 函数返回

函数返回可以看成调用函数的逆过程。函数return后的变化，伪代码如下：

```
esp = ebp
ebp = pop ; 恢复栈帧
ip = pop ; 返回 (事实上 ret 指令一并操作了 ip 和 esp 并保证了线程安全)
```

这里和调用的过程非常对称，这里用esp指向了ebp所指的位置，用ebp指向的栈里面储存的caller的ebp恢复了ebp，最后把ip指向了caller调用函数的下一条指令。

如果callee有返回值，则这个返回值将临时保存在**寄存器**里（编译器可以自动选择，而汇编语言得自己手动指定寄存器并保存），由caller从寄存器里取出来。开始返回后，栈逐渐清空，将返回数据保存后，清除全部局部变量（除了静态局部变量），然后恢复caller的栈帧，恢复pc指针，开始继续执行。

##### 后续

以上就是我认为应该了解的函数调用的堆栈变化了。以后会陆续补充其他方面的总结，比如计算机内第一个程序是怎么运行的，进程是怎么管理的，程序是怎么装载进入内存的等操作系统的知识，也有一些计算机网络的知识，更底层的计算机组成原理可能就不会涉及多少了。如果有错别字之类的，或者知识的误区，请务必与我联系并告知，邮箱在主页就有，感谢！



[关于储存类型，作用域和链接属性的拓展阅读]: https://www.cnblogs.com/keviwu/p/5903962.html	"关于储存类型，作用域和链接属性的拓展阅读"

